// Express.js middleware code generator

use crate::policy::rules::PolicyFile;
use crate::policy::types::PolicyRule;
use chrono::Utc;

/// Generate Express.js middleware from policy configuration
pub fn generate_express_middleware(policy_file_content: &PolicyFile, policy_file_name: &str) -> String {
    let mut code = String::new();

    // Header with generation metadata
    code.push_str(&generate_header(policy_file_name));
    code.push('\n');

    // Helper functions
    code.push_str(&generate_helper_functions(policy_file_content));
    code.push('\n');

    // Main middleware function
    code.push_str(&generate_middleware_function(policy_file_content));

    code
}

fn generate_header(policy_file: &str) -> String {
    format!(
        r#"// Generated by: x402-dev policy generate {}
// Generated: {}
// DO NOT EDIT THIS FILE MANUALLY - Regenerate from policy file

"#,
        policy_file,
        Utc::now().format("%Y-%m-%d %H:%M:%S UTC")
    )
}

fn generate_helper_functions(config: &PolicyFile) -> String {
    let mut code = String::new();

    // Rate limit checker
    if config.policies.iter().any(|p| matches!(p, PolicyRule::RateLimit { .. })) {
        code.push_str(&generate_rate_limit_helper());
        code.push('\n');
    }

    // Spending cap checker
    if config.policies.iter().any(|p| matches!(p, PolicyRule::SpendingCap { .. })) {
        code.push_str(&generate_spending_cap_helper());
        code.push('\n');
    }

    // Invoice generator
    code.push_str(&generate_invoice_helper(config));
    code.push('\n');

    // Audit logger
    if config.audit.enabled {
        code.push_str(&generate_audit_logger(config));
    }

    code
}

fn generate_rate_limit_helper() -> String {
    r#"// Rate limit tracking (in-memory, use Redis for production)
const rateLimitStore = new Map();

/**
 * Check if rate limit is exceeded for an agent
 * @param {string} agentId - The agent identifier
 * @param {number} maxRequests - Maximum requests allowed
 * @param {number} windowSeconds - Time window in seconds
 * @returns {boolean} true if rate limit exceeded
 */
function rateLimitExceeded(agentId, maxRequests, windowSeconds) {
  const now = Date.now();
  const key = `ratelimit:${agentId}`;

  if (!rateLimitStore.has(key)) {
    rateLimitStore.set(key, []);
  }

  const timestamps = rateLimitStore.get(key);
  const windowStart = now - (windowSeconds * 1000);

  // Remove expired timestamps
  const validTimestamps = timestamps.filter(ts => ts > windowStart);
  rateLimitStore.set(key, validTimestamps);

  // Check if limit exceeded
  if (validTimestamps.length >= maxRequests) {
    return true;
  }

  // Add current request timestamp
  validTimestamps.push(now);
  rateLimitStore.set(key, validTimestamps);

  return false;
}
"#.to_string()
}

fn generate_spending_cap_helper() -> String {
    r#"// Spending tracking (in-memory, use database for production)
const spendingStore = new Map();

/**
 * Check if spending cap is exceeded for an agent
 * @param {string} agentId - The agent identifier
 * @param {number} amount - Current request amount
 * @param {number} maxAmount - Maximum spending allowed
 * @param {string} period - Time period ('daily', 'weekly', 'monthly')
 * @returns {boolean} true if spending cap exceeded
 */
function spendingCapExceeded(agentId, amount, maxAmount, period) {
  const now = Date.now();
  const key = `spending:${agentId}:${period}`;

  if (!spendingStore.has(key)) {
    spendingStore.set(key, { total: 0, resetAt: getNextResetTime(period) });
  }

  const spending = spendingStore.get(key);

  // Reset if period elapsed
  if (now >= spending.resetAt) {
    spending.total = 0;
    spending.resetAt = getNextResetTime(period);
  }

  // Check if adding this amount would exceed cap
  if (spending.total + amount > maxAmount) {
    return true;
  }

  // Add to spending
  spending.total += amount;
  spendingStore.set(key, spending);

  return false;
}

/**
 * Calculate next reset time for spending period
 * @param {string} period - 'daily', 'weekly', or 'monthly'
 * @returns {number} timestamp in milliseconds
 */
function getNextResetTime(period) {
  const now = new Date();

  switch (period) {
    case 'daily':
      now.setHours(24, 0, 0, 0);
      return now.getTime();
    case 'weekly':
      const daysUntilMonday = (8 - now.getDay()) % 7;
      now.setDate(now.getDate() + daysUntilMonday);
      now.setHours(0, 0, 0, 0);
      return now.getTime();
    case 'monthly':
      now.setMonth(now.getMonth() + 1, 1);
      now.setHours(0, 0, 0, 0);
      return now.getTime();
    default:
      return now.getTime() + (24 * 60 * 60 * 1000); // Default to 24h
  }
}
"#.to_string()
}

fn generate_invoice_helper(config: &PolicyFile) -> String {
    format!(
        r#"/**
 * Generate x402 payment invoice
 * @param {{string}} agentId - The agent identifier
 * @param {{string}} resource - The requested resource
 * @returns {{string}} WWW-Authenticate header value
 */
function generateInvoice(agentId, resource) {{
  const amount = {};
  const currency = '{}';
  const memoPrefix = {};
  const memo = memoPrefix ? `${{memoPrefix}}_req_${{Date.now()}}` : `req_${{Date.now()}}`;

  // Simplified invoice format (replace with actual x402 protocol format)
  const invoice = `x402 amount="${{amount}}" currency="${{currency}}" memo="${{memo}}" agent="${{agentId}}" resource="${{resource}}"`;

  return invoice;
}}
"#,
        config.pricing.amount,
        config.pricing.currency,
        config.pricing.memo_prefix.as_ref()
            .map(|s| format!("'{}'", s))
            .unwrap_or_else(|| "null".to_string())
    )
}

fn generate_audit_logger(config: &PolicyFile) -> String {
    let format = &config.audit.format;
    let destination = config.audit.destination.as_deref().unwrap_or("stdout");

    format!(
        r#"/**
 * Log payment attempt for audit trail
 * @param {{string}} agentId - The agent identifier
 * @param {{string}} resource - The requested resource
 * @param {{string}} action - The action taken ('payment_required', 'rate_limited', 'denied', etc.)
 * @param {{string}} result - The result ('success', 'failure', etc.)
 */
function logPaymentAttempt(agentId, resource, action, result) {{
  const timestamp = new Date().toISOString();
  const logEntry = {{
    timestamp,
    agent_id: agentId,
    resource,
    action,
    result
  }};

  const format = '{}';
  const destination = '{}';

  let logLine;
  if (format === 'csv') {{
    // CSV format: timestamp,agent_id,resource,action,result
    logLine = `${{timestamp}},${{agentId}},${{resource}},${{action}},${{result}}`;
  }} else {{
    // JSON format
    logLine = JSON.stringify(logEntry);
  }}

  // Output to destination
  if (destination === 'stdout') {{
    console.log(logLine);
  }} else {{
    // In production, write to file or send to logging service
    // For now, just log to console
    console.log(`[AUDIT:${{destination}}] ${{logLine}}`);
  }}
}}
"#,
        format,
        destination
    )
}

fn generate_middleware_function(config: &PolicyFile) -> String {
    let mut code = String::new();

    code.push_str(
        r#"/**
 * x402 Payment middleware with policy enforcement
 * @param {object} req - Express request object
 * @param {object} res - Express response object
 * @param {function} next - Express next middleware function
 */
const x402Middleware = (req, res, next) => {
  // Extract agent ID from header
  const agentId = req.headers['x-agent-id'] || req.headers['x-forwarded-for'] || 'unknown';
  const resource = req.path;

"#,
    );

    // Generate policy checks
    for policy in &config.policies {
        match policy {
            PolicyRule::Allowlist { field: _, values } => {
                code.push_str("  // Allowlist policy check\n");
                code.push_str(&format!("  const allowedAgents = {};\n",
                    serde_json::to_string(values).unwrap()));
                code.push_str(
                    r#"  if (!allowedAgents.includes(agentId)) {
    if (logPaymentAttempt) {
      logPaymentAttempt(agentId, resource, 'allowlist_check', 'denied');
    }
    return res.status(403).json({ error: 'Agent not allowed' });
  }

"#,
                );
            }
            PolicyRule::Denylist { field: _, values } => {
                code.push_str("  // Denylist policy check\n");
                code.push_str(&format!("  const deniedAgents = {};\n",
                    serde_json::to_string(values).unwrap()));
                code.push_str(
                    r#"  if (deniedAgents.includes(agentId)) {
    if (logPaymentAttempt) {
      logPaymentAttempt(agentId, resource, 'denylist_check', 'denied');
    }
    return res.status(403).json({ error: 'Agent denied' });
  }

"#,
                );
            }
            PolicyRule::RateLimit { max_requests, window_seconds } => {
                code.push_str("  // Rate limit policy check\n");
                code.push_str(&format!(
                    r#"  if (rateLimitExceeded(agentId, {}, {})) {{
    if (logPaymentAttempt) {{
      logPaymentAttempt(agentId, resource, 'rate_limit_check', 'exceeded');
    }}
    return res.status(429).json({{ error: 'Rate limit exceeded', retry_after: {} }});
  }}

"#,
                    max_requests, window_seconds, window_seconds
                ));
            }
            PolicyRule::SpendingCap { max_amount, currency, window_seconds } => {
                code.push_str("  // Spending cap policy check\n");
                code.push_str(&format!(
                    r#"  const requestAmount = {}; // Amount for this request
  if (spendingCapExceeded(agentId, requestAmount, {}, '{}')) {{
    if (logPaymentAttempt) {{
      logPaymentAttempt(agentId, resource, 'spending_cap_check', 'exceeded');
    }}
    return res.status(402).json({{
      error: 'Spending cap exceeded',
      max_amount: {},
      period: '{}',
      currency: '{}'
    }});
  }}

"#,
                    0.01, max_amount, window_seconds, max_amount, window_seconds, currency
                ));
            }
        }
    }

    // Generate 402 response with invoice
    code.push_str(
        r#"  // Generate 402 Payment Required response with invoice
  const invoice = generateInvoice(agentId, resource);

"#,
    );

    if config.audit.enabled {
        code.push_str(
            r#"  // Log payment attempt
  logPaymentAttempt(agentId, resource, 'payment_required', 'pending');

"#,
        );
    }

    code.push_str(
        r#"  // Return 402 Payment Required with invoice
  res.status(402)
     .set('WWW-Authenticate', invoice)
     .json({
       error: 'Payment Required',
       invoice: invoice,
       amount: "#,
    );
    code.push_str(&format!("{}", config.pricing.amount));
    code.push_str(",\n       currency: '");
    code.push_str(&config.pricing.currency);
    code.push_str(
        r#"'
     });
};

module.exports = x402Middleware;
"#,
    );

    code
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::policy::rules::{PolicyFile, AuditConfig, PricingConfig};

    #[test]
    fn test_generate_header() {
        let header = generate_header("policy.yaml");
        assert!(header.contains("x402-dev policy generate policy.yaml"));
        assert!(header.contains("DO NOT EDIT"));
    }

    #[test]
    fn test_generate_rate_limit_helper() {
        let helper = generate_rate_limit_helper();
        assert!(helper.contains("function rateLimitExceeded"));
        assert!(helper.contains("rateLimitStore"));
    }

    #[test]
    fn test_generate_spending_cap_helper() {
        let helper = generate_spending_cap_helper();
        assert!(helper.contains("function spendingCapExceeded"));
        assert!(helper.contains("spendingStore"));
        assert!(helper.contains("getNextResetTime"));
    }

    #[test]
    fn test_generate_invoice_helper() {
        let config = PolicyFile {
            policies: vec![],
            pricing: PricingConfig {
                amount: 0.02,
                currency: "SOL".to_string(),
                memo_prefix: Some("test".to_string()),
            },
            audit: AuditConfig::default(),
        };

        let helper = generate_invoice_helper(&config);
        assert!(helper.contains("function generateInvoice"));
        assert!(helper.contains("0.02"));
        assert!(helper.contains("SOL"));
        assert!(helper.contains("'test'"));
    }

    #[test]
    fn test_generate_audit_logger() {
        let config = PolicyFile {
            policies: vec![],
            pricing: PricingConfig::default(),
            audit: AuditConfig {
                enabled: true,
                format: "csv".to_string(),
                destination: Some("/var/log/audit.csv".to_string()),
            },
        };

        let logger = generate_audit_logger(&config);
        assert!(logger.contains("function logPaymentAttempt"));
        assert!(logger.contains("csv"));
        assert!(logger.contains("/var/log/audit.csv"));
    }

    #[test]
    fn test_generate_middleware_with_allowlist() {
        let config = PolicyFile {
            policies: vec![PolicyRule::Allowlist {
                field: "agent_id".to_string(),
                values: vec!["agent-1".to_string(), "agent-2".to_string()],
            }],
            pricing: PricingConfig::default(),
            audit: AuditConfig::default(),
        };

        let code = generate_express_middleware(&config, "test.yaml");
        assert!(code.contains("x402Middleware"));
        assert!(code.contains("allowedAgents"));
        assert!(code.contains("agent-1"));
        assert!(code.contains("agent-2"));
        assert!(code.contains("status(403)"));
    }

    #[test]
    fn test_generate_middleware_with_rate_limit() {
        let config = PolicyFile {
            policies: vec![PolicyRule::RateLimit {
                max_requests: 100,
                window_seconds: 3600,
            }],
            pricing: PricingConfig::default(),
            audit: AuditConfig::default(),
        };

        let code = generate_express_middleware(&config, "test.yaml");
        assert!(code.contains("rateLimitExceeded"));
        assert!(code.contains("100"));
        assert!(code.contains("3600"));
        assert!(code.contains("status(429)"));
    }

    #[test]
    fn test_generate_complete_middleware() {
        let config = PolicyFile {
            policies: vec![
                PolicyRule::Allowlist {
                    field: "agent_id".to_string(),
                    values: vec!["agent-123".to_string()],
                },
                PolicyRule::RateLimit {
                    max_requests: 50,
                    window_seconds: 60,
                },
            ],
            pricing: PricingConfig {
                amount: 0.01,
                currency: "USDC".to_string(),
                memo_prefix: None,
            },
            audit: AuditConfig {
                enabled: true,
                format: "json".to_string(),
                destination: Some("stdout".to_string()),
            },
        };

        let code = generate_express_middleware(&config, "policy.yaml");

        // Check header
        assert!(code.contains("Generated by: x402-dev"));

        // Check helpers
        assert!(code.contains("function rateLimitExceeded"));
        assert!(code.contains("function generateInvoice"));
        assert!(code.contains("function logPaymentAttempt"));

        // Check middleware
        assert!(code.contains("const x402Middleware"));
        assert!(code.contains("allowedAgents"));
        assert!(code.contains("rateLimitExceeded"));
        assert!(code.contains("status(402)"));
        assert!(code.contains("WWW-Authenticate"));

        // Check export
        assert!(code.contains("module.exports"));
    }
}
