// Fastify plugin code generation from policy rules

use crate::policy::types::PolicyRule;
use chrono::Utc;

/// Generate Fastify plugin code from policy rules
///
/// Creates a production-ready Fastify plugin with:
/// - Proper fastify-plugin wrapper
/// - JSON Schema validation
/// - preHandler hook for policy enforcement
/// - 402 Payment Required responses with invoices
/// - Comprehensive audit logging
///
/// # Arguments
/// * `policies` - Vector of policy rules to enforce
/// * `policy_filename` - Optional source policy file name for documentation
///
/// # Returns
/// Complete JavaScript code as a String
pub fn generate_fastify_plugin(policies: &[PolicyRule], policy_filename: Option<&str>) -> String {
    let timestamp = Utc::now().format("%Y-%m-%d %H:%M:%S UTC");
    let filename = policy_filename.unwrap_or("policy.yaml");

    let mut code = format!(
        r#"// Generated by: x402-dev policy generate
// Policy file: {}
// Generated: {}
// Framework: Fastify.js
//
// This is a production-ready Fastify plugin implementing x402 protocol
// payment enforcement with the policies defined in your YAML file.
//
// Installation:
//   npm install fastify fastify-plugin
//
// Usage:
//   const fastify = require('fastify')();
//   const x402Plugin = require('./x402-policy-plugin');
//
//   fastify.register(x402Plugin);
//   fastify.listen({{ port: 3000 }});

'use strict';

const fp = require('fastify-plugin');

"#,
        filename, timestamp
    );

    // Generate schema definitions
    code.push_str(&generate_schemas(policies));

    // Generate helper functions (rate limiting, spending tracking, etc.)
    code.push_str(&generate_helpers(policies));

    // Generate main plugin function
    code.push_str(&generate_plugin_function(policies));

    // Export with metadata
    code.push_str(&r#"
// Export plugin with metadata
module.exports = fp(x402PolicyPlugin, {
  fastify: '4.x',
  name: 'x402-policy-plugin',
  decorators: {
    request: [],
    reply: []
  }
});
"#.to_string());

    code
}

/// Generate JSON Schema definitions for validation
fn generate_schemas(policies: &[PolicyRule]) -> String {
    let mut required_headers = Vec::new();

    // Determine required headers based on policies
    for policy in policies {
        match policy {
            PolicyRule::Allowlist { field, .. } | PolicyRule::Denylist { field, .. } => {
                if field == "agent_id" && !required_headers.contains(&"x-agent-id") {
                    required_headers.push("x-agent-id");
                } else if field == "wallet_address" && !required_headers.contains(&"x-wallet-address") {
                    required_headers.push("x-wallet-address");
                }
            }
            _ => {}
        }
    }

    let required_array = if required_headers.is_empty() {
        "[]".to_string()
    } else {
        format!(
            "['{}']",
            required_headers.join("', '")
        )
    };

    format!(
        r#"// JSON Schema for request validation
const requestSchema = {{
  type: 'object',
  properties: {{
    headers: {{
      type: 'object',
      properties: {{
        'x-agent-id': {{ type: 'string' }},
        'x-wallet-address': {{ type: 'string' }},
        'x-request-id': {{ type: 'string' }}
      }},
      required: {}
    }}
  }}
}};

"#,
        required_array
    )
}

/// Generate helper functions for policy enforcement
fn generate_helpers(policies: &[PolicyRule]) -> String {
    let mut code = String::new();

    // Check if we need rate limiting
    let has_rate_limit = policies.iter().any(|p| matches!(p, PolicyRule::RateLimit { .. }));
    if has_rate_limit {
        code.push_str(
            r#"// Rate limiting state (in-memory, use Redis in production)
const rateLimitStore = new Map();

function checkRateLimit(agentId, maxRequests, windowSeconds) {
  const now = Date.now();
  const windowMs = windowSeconds * 1000;
  const key = `rate:${agentId}`;

  if (!rateLimitStore.has(key)) {
    rateLimitStore.set(key, []);
  }

  const requests = rateLimitStore.get(key);

  // Remove expired entries
  const validRequests = requests.filter(timestamp => now - timestamp < windowMs);

  if (validRequests.length >= maxRequests) {
    return false; // Rate limit exceeded
  }

  // Add current request
  validRequests.push(now);
  rateLimitStore.set(key, validRequests);

  return true; // Within rate limit
}

"#,
        );
    }

    // Check if we need spending tracking
    let has_spending_cap = policies.iter().any(|p| matches!(p, PolicyRule::SpendingCap { .. }));
    if has_spending_cap {
        code.push_str(
            r#"// Spending tracking state (in-memory, use database in production)
const spendingStore = new Map();

function checkSpendingCap(agentId, amount, maxAmount, windowSeconds) {
  const now = Date.now();
  const windowMs = windowSeconds * 1000;
  const key = `spending:${agentId}`;

  if (!spendingStore.has(key)) {
    spendingStore.set(key, []);
  }

  const payments = spendingStore.get(key);

  // Remove expired entries
  const validPayments = payments.filter(entry => now - entry.timestamp < windowMs);

  // Calculate total spending
  const totalSpent = validPayments.reduce((sum, entry) => sum + entry.amount, 0);

  if (totalSpent + amount > maxAmount) {
    return false; // Spending cap exceeded
  }

  // Add current payment
  validPayments.push({ timestamp: now, amount });
  spendingStore.set(key, validPayments);

  return true; // Within spending cap
}

"#,
        );
    }

    // Invoice generation
    code.push_str(
        r#"// Generate x402 invoice for payment
function generateInvoice(amount, currency, memo, network = 'devnet') {
  const recipient = process.env.X402_RECIPIENT || 'Dev123456789';

  return `x402-solana recipient=${recipient} amount=${amount} currency=${currency} memo=${memo} network=${network}`;
}

// Audit logging
function logAuditEvent(event) {
  const logEntry = {
    timestamp: new Date().toISOString(),
    ...event
  };

  // Log to console (use proper logging in production: pino, winston, etc.)
  console.log(JSON.stringify(logEntry));
}

"#,
    );

    code
}

/// Generate main plugin function with policy enforcement
fn generate_plugin_function(policies: &[PolicyRule]) -> String {
    let mut code = String::from(
        r#"// Main Fastify plugin function
async function x402PolicyPlugin(fastify, options) {
  // Add preHandler hook for policy enforcement
  fastify.addHook('preHandler', async (request, reply) => {
    const agentId = request.headers['x-agent-id'];
    const walletAddress = request.headers['x-wallet-address'];
    const requestId = request.headers['x-request-id'] || `req_${Date.now()}`;

    logAuditEvent({
      event: 'payment_request',
      agent_id: agentId,
      wallet_address: walletAddress,
      request_id: requestId,
      url: request.url,
      method: request.method
    });

"#,
    );

    // Generate policy checks in order
    for (idx, policy) in policies.iter().enumerate() {
        code.push_str(&format!("    // Policy {}: {:?}\n", idx + 1, policy));

        match policy {
            PolicyRule::Allowlist { field, values } => {
                let field_var = match field.as_str() {
                    "agent_id" => "agentId",
                    "wallet_address" => "walletAddress",
                    _ => "agentId", // default
                };

                code.push_str(&format!(
                    r#"    const allowedValues_{} = [{}];
    if (!allowedValues_{}.includes({})) {{
      logAuditEvent({{
        event: 'policy_denied',
        policy: 'allowlist',
        field: '{}',
        value: {},
        reason: 'not in allowlist'
      }});
      return reply.code(403).send({{ error: 'Agent not allowed' }});
    }}

"#,
                    idx,
                    values.iter().map(|v| format!("'{}'", v)).collect::<Vec<_>>().join(", "),
                    idx,
                    field_var,
                    field,
                    field_var
                ));
            }

            PolicyRule::Denylist { field, values } => {
                let field_var = match field.as_str() {
                    "agent_id" => "agentId",
                    "wallet_address" => "walletAddress",
                    _ => "agentId",
                };

                code.push_str(&format!(
                    r#"    const deniedValues_{} = [{}];
    if (deniedValues_{}.includes({})) {{
      logAuditEvent({{
        event: 'policy_denied',
        policy: 'denylist',
        field: '{}',
        value: {},
        reason: 'in denylist'
      }});
      return reply.code(403).send({{ error: 'Agent blocked' }});
    }}

"#,
                    idx,
                    values.iter().map(|v| format!("'{}'", v)).collect::<Vec<_>>().join(", "),
                    idx,
                    field_var,
                    field,
                    field_var
                ));
            }

            PolicyRule::RateLimit { max_requests, window_seconds } => {
                code.push_str(&format!(
                    r#"    if (!checkRateLimit(agentId, {}, {})) {{
      logAuditEvent({{
        event: 'policy_denied',
        policy: 'rate_limit',
        agent_id: agentId,
        reason: 'rate limit exceeded'
      }});
      return reply.code(429).send({{ error: 'Rate limit exceeded' }});
    }}

"#,
                    max_requests, window_seconds
                ));
            }

            PolicyRule::SpendingCap { max_amount, currency, window_seconds } => {
                code.push_str(&format!(
                    r#"    const paymentAmount_{} = parseFloat(request.headers['x-payment-amount'] || '0.01');
    if (!checkSpendingCap(agentId, paymentAmount_{}, {}, {})) {{
      logAuditEvent({{
        event: 'policy_denied',
        policy: 'spending_cap',
        agent_id: agentId,
        amount: paymentAmount_{},
        max_amount: {},
        currency: '{}',
        reason: 'spending cap exceeded'
      }});
      return reply.code(403).send({{ error: 'Spending cap exceeded' }});
    }}

"#,
                    idx, idx, max_amount, window_seconds, idx, max_amount, currency
                ));
            }
        }
    }

    // Generate 402 response with invoice
    code.push_str(
        r#"    // All policies passed, generate 402 Payment Required response
    const amount = parseFloat(request.headers['x-payment-amount'] || '0.01');
    const currency = request.headers['x-payment-currency'] || 'USDC';
    const network = request.headers['x-network'] || 'devnet';
    const memo = requestId;

    const invoice = generateInvoice(amount, currency, memo, network);

    logAuditEvent({
      event: 'payment_required',
      agent_id: agentId,
      request_id: requestId,
      amount,
      currency,
      network,
      invoice
    });

    return reply
      .code(402)
      .header('WWW-Authenticate', invoice)
      .send({ error: 'Payment Required', invoice });
  });

  // Optional: Add a test route
  fastify.get('/api/test', async (request, reply) => {
    return { message: 'This route is protected by x402 policies' };
  });
}

"#,
    );

    code
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_basic_fastify_plugin() {
        let policies = vec![
            PolicyRule::Allowlist {
                field: "agent_id".to_string(),
                values: vec!["agent-123".to_string(), "agent-456".to_string()],
            },
        ];

        let code = generate_fastify_plugin(&policies, Some("test.yaml"));

        // Check key components are present
        assert!(code.contains("fastify-plugin"));
        assert!(code.contains("preHandler"));
        assert!(code.contains("allowlist"));
        assert!(code.contains("402"));
        assert!(code.contains("WWW-Authenticate"));
        assert!(code.contains("logAuditEvent"));
        assert!(code.contains("agent-123"));
    }

    #[test]
    fn test_generate_rate_limit_plugin() {
        let policies = vec![
            PolicyRule::RateLimit {
                max_requests: 100,
                window_seconds: 3600,
            },
        ];

        let code = generate_fastify_plugin(&policies, None);

        assert!(code.contains("checkRateLimit"));
        assert!(code.contains("rateLimitStore"));
        assert!(code.contains("100"));
        assert!(code.contains("3600"));
        assert!(code.contains("429")); // Rate limit status code
    }

    #[test]
    fn test_generate_spending_cap_plugin() {
        let policies = vec![
            PolicyRule::SpendingCap {
                max_amount: 10.0,
                currency: "USDC".to_string(),
                window_seconds: 86400,
            },
        ];

        let code = generate_fastify_plugin(&policies, None);

        assert!(code.contains("checkSpendingCap"));
        assert!(code.contains("spendingStore"));
        assert!(code.contains("10"));
        assert!(code.contains("USDC"));
        assert!(code.contains("86400"));
    }

    #[test]
    fn test_generate_complex_plugin() {
        let policies = vec![
            PolicyRule::Allowlist {
                field: "agent_id".to_string(),
                values: vec!["agent-abc-123".to_string()],
            },
            PolicyRule::RateLimit {
                max_requests: 100,
                window_seconds: 3600,
            },
            PolicyRule::SpendingCap {
                max_amount: 10.0,
                currency: "USDC".to_string(),
                window_seconds: 86400,
            },
        ];

        let code = generate_fastify_plugin(&policies, Some("complex.yaml"));

        // All policy types should be present
        assert!(code.contains("allowlist"));
        assert!(code.contains("checkRateLimit"));
        assert!(code.contains("checkSpendingCap"));
        assert!(code.contains("complex.yaml"));
    }

    #[test]
    fn test_audit_logging_included() {
        let policies = vec![];
        let code = generate_fastify_plugin(&policies, None);

        assert!(code.contains("logAuditEvent"));
        assert!(code.contains("payment_request"));
        assert!(code.contains("payment_required"));
    }
}
