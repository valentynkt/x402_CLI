// Express.js middleware code generator

use crate::policy::rules::{PolicyFile, PolicyRule, PolicyType};
use chrono::Utc;

/// Generate Express.js middleware from policy configuration
pub fn generate_express_middleware(policy_file: &PolicyFile, policy_filename: &str) -> String {
    let mut code = String::new();

    // Header with generation metadata
    code.push_str(&generate_header(policy_filename));
    code.push('\n');

    // Helper functions
    code.push_str(&generate_helper_functions(policy_file));
    code.push('\n');

    // Main middleware function
    code.push_str(&generate_middleware_function(policy_file));

    code
}

fn generate_header(policy_filename: &str) -> String {
    format!(
        r#"// Generated by: x402-dev policy generate {}
// Generated: {}
// DO NOT EDIT THIS FILE MANUALLY - Regenerate from policy file

"#,
        policy_filename,
        Utc::now().format("%Y-%m-%d %H:%M:%S UTC")
    )
}

fn generate_helper_functions(policy_file: &PolicyFile) -> String {
    let mut code = String::new();

    // Check which helpers are needed
    let has_rate_limit = policy_file.policies.iter().any(|p| p.is_rate_limit());
    let has_spending_cap = policy_file.policies.iter().any(|p| p.is_spending_cap());

    // Rate limit checker
    if has_rate_limit {
        code.push_str(&generate_rate_limit_helper());
        code.push('\n');
    }

    // Spending cap checker
    if has_spending_cap {
        code.push_str(&generate_spending_cap_helper());
        code.push('\n');
    }

    // Invoice generator (always included)
    code.push_str(&generate_invoice_helper());
    code.push('\n');

    // Audit logger (always included for now)
    code.push_str(&generate_audit_logger());

    code
}

fn generate_rate_limit_helper() -> String {
    r#"// Rate limit tracking (in-memory, use Redis for production)
const rateLimitStore = new Map();

/**
 * Check if rate limit is exceeded for an agent
 * @param {string} agentId - The agent identifier
 * @param {number} maxRequests - Maximum requests allowed
 * @param {number} windowSeconds - Time window in seconds
 * @returns {boolean} true if rate limit exceeded
 */
function rateLimitExceeded(agentId, maxRequests, windowSeconds) {
  const now = Date.now();
  const key = `ratelimit:${agentId}`;

  if (!rateLimitStore.has(key)) {
    rateLimitStore.set(key, []);
  }

  const timestamps = rateLimitStore.get(key);
  const windowStart = now - (windowSeconds * 1000);

  // Remove expired timestamps
  const validTimestamps = timestamps.filter(ts => ts > windowStart);
  rateLimitStore.set(key, validTimestamps);

  // Check if limit exceeded
  if (validTimestamps.length >= maxRequests) {
    return true;
  }

  // Add current request timestamp
  validTimestamps.push(now);
  rateLimitStore.set(key, validTimestamps);

  return false;
}
"#.to_string()
}

fn generate_spending_cap_helper() -> String {
    r#"// Spending tracking (in-memory, use database for production)
const spendingStore = new Map();

/**
 * Check if spending cap is exceeded for an agent
 * @param {string} agentId - The agent identifier
 * @param {number} amount - Current request amount
 * @param {number} maxAmount - Maximum spending allowed
 * @param {number} windowSeconds - Time window in seconds
 * @returns {boolean} true if spending cap exceeded
 */
function spendingCapExceeded(agentId, amount, maxAmount, windowSeconds) {
  const now = Date.now();
  const key = `spending:${agentId}`;

  if (!spendingStore.has(key)) {
    spendingStore.set(key, { total: 0, resetAt: now + (windowSeconds * 1000) });
  }

  const spending = spendingStore.get(key);

  // Reset if window elapsed
  if (now >= spending.resetAt) {
    spending.total = 0;
    spending.resetAt = now + (windowSeconds * 1000);
  }

  // Check if adding this amount would exceed cap
  if (spending.total + amount > maxAmount) {
    return true;
  }

  // Add to spending
  spending.total += amount;
  spendingStore.set(key, spending);

  return false;
}
"#.to_string()
}

fn generate_invoice_helper() -> String {
    r#"/**
 * Generate x402 payment invoice
 * @param {string} agentId - The agent identifier
 * @param {string} resource - The requested resource
 * @param {number} amount - Payment amount
 * @param {string} currency - Currency code
 * @returns {string} WWW-Authenticate header value
 */
function generateInvoice(agentId, resource, amount, currency) {
  const memo = `req_${Date.now()}`;

  // Simplified invoice format (replace with actual x402 protocol format)
  const invoice = `x402 amount="${amount}" currency="${currency}" memo="${memo}" agent="${agentId}" resource="${resource}"`;

  return invoice;
}
"#.to_string()
}

fn generate_audit_logger() -> String {
    r#"/**
 * Log payment attempt for audit trail
 * @param {string} agentId - The agent identifier
 * @param {string} resource - The requested resource
 * @param {string} action - The action taken ('payment_required', 'rate_limited', 'denied', etc.)
 * @param {string} result - The result ('success', 'failure', etc.)
 */
function logPaymentAttempt(agentId, resource, action, result) {
  const timestamp = new Date().toISOString();
  const logEntry = {
    timestamp,
    agent_id: agentId,
    resource,
    action,
    result
  };

  // JSON format for logging
  const logLine = JSON.stringify(logEntry);
  console.log(logLine);
}
"#.to_string()
}

fn generate_middleware_function(policy_file: &PolicyFile) -> String {
    let mut code = String::new();

    // Default pricing (can be extracted from config if available)
    let default_amount = 0.01;
    let default_currency = "USDC";

    code.push_str(
        r#"/**
 * x402 Payment middleware with policy enforcement
 * @param {object} req - Express request object
 * @param {object} res - Express response object
 * @param {function} next - Express next middleware function
 */
const x402Middleware = (req, res, next) => {
  // Extract agent ID from header
  const agentId = req.headers['x-agent-id'] || req.headers['x-forwarded-for'] || 'unknown';
  const resource = req.path;

"#,
    );

    // Generate policy checks
    for policy in &policy_file.policies {
        match policy.policy_type {
            PolicyType::Allowlist => {
                if let Some(values) = &policy.values {
                    code.push_str("  // Allowlist policy check\n");
                    code.push_str(&format!("  const allowedAgents = {};\n",
                        serde_json::to_string(values).unwrap()));
                    let field = policy.field.as_deref().unwrap_or("agent_id");
                    code.push_str(&format!(
                        r#"  if (!allowedAgents.includes(agentId)) {{
    logPaymentAttempt(agentId, resource, 'allowlist_check', 'denied');
    return res.status(403).json({{ error: 'Agent not in allowlist (field: {})' }});
  }}

"#,
                        field
                    ));
                }
            }
            PolicyType::Denylist => {
                if let Some(values) = &policy.values {
                    code.push_str("  // Denylist policy check\n");
                    code.push_str(&format!("  const deniedAgents = {};\n",
                        serde_json::to_string(values).unwrap()));
                    let field = policy.field.as_deref().unwrap_or("agent_id");
                    code.push_str(&format!(
                        r#"  if (deniedAgents.includes(agentId)) {{
    logPaymentAttempt(agentId, resource, 'denylist_check', 'denied');
    return res.status(403).json({{ error: 'Agent in denylist (field: {})' }});
  }}

"#,
                        field
                    ));
                }
            }
            PolicyType::RateLimit => {
                if let (Some(max_requests), Some(window)) = (policy.max_requests, policy.window_seconds) {
                    code.push_str("  // Rate limit policy check\n");
                    code.push_str(&format!(
                        r#"  if (rateLimitExceeded(agentId, {}, {})) {{
    logPaymentAttempt(agentId, resource, 'rate_limit_check', 'exceeded');
    return res.status(429).json({{ error: 'Rate limit exceeded', retry_after: {} }});
  }}

"#,
                        max_requests, window, window
                    ));
                }
            }
            PolicyType::SpendingCap => {
                if let (Some(max_amount), Some(window)) = (policy.max_amount, policy.window_seconds) {
                    let currency = policy.currency.as_deref().unwrap_or(default_currency);
                    code.push_str("  // Spending cap policy check\n");
                    code.push_str(&format!(
                        r#"  const requestAmount = {}; // Amount for this request
  if (spendingCapExceeded(agentId, requestAmount, {}, {})) {{
    logPaymentAttempt(agentId, resource, 'spending_cap_check', 'exceeded');
    return res.status(402).json({{
      error: 'Spending cap exceeded',
      max_amount: {},
      window_seconds: {},
      currency: '{}'
    }});
  }}

"#,
                        default_amount, max_amount, window, max_amount, window, currency
                    ));
                }
            }
        }
    }

    // Generate 402 response with invoice
    code.push_str(&format!(
        r#"  // Generate 402 Payment Required response with invoice
  const invoice = generateInvoice(agentId, resource, {}, '{}');

  // Log payment attempt
  logPaymentAttempt(agentId, resource, 'payment_required', 'pending');

  // Return 402 Payment Required with invoice
  res.status(402)
     .set('WWW-Authenticate', invoice)
     .json({{
       error: 'Payment Required',
       invoice: invoice,
       amount: {},
       currency: '{}'
     }});
}};

module.exports = x402Middleware;
"#,
        default_amount, default_currency, default_amount, default_currency
    ));

    code
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_header() {
        let header = generate_header("policy.yaml");
        assert!(header.contains("x402-dev policy generate policy.yaml"));
        assert!(header.contains("DO NOT EDIT"));
    }

    #[test]
    fn test_generate_rate_limit_helper() {
        let helper = generate_rate_limit_helper();
        assert!(helper.contains("function rateLimitExceeded"));
        assert!(helper.contains("rateLimitStore"));
    }

    #[test]
    fn test_generate_spending_cap_helper() {
        let helper = generate_spending_cap_helper();
        assert!(helper.contains("function spendingCapExceeded"));
        assert!(helper.contains("spendingStore"));
    }

    #[test]
    fn test_generate_invoice_helper() {
        let helper = generate_invoice_helper();
        assert!(helper.contains("function generateInvoice"));
        assert!(helper.contains("x402"));
    }

    #[test]
    fn test_generate_audit_logger() {
        let logger = generate_audit_logger();
        assert!(logger.contains("function logPaymentAttempt"));
        assert!(logger.contains("timestamp"));
    }

    #[test]
    fn test_generate_middleware_with_allowlist() {
        let policy_file = PolicyFile {
            policies: vec![PolicyRule {
                policy_type: PolicyType::Allowlist,
                field: Some("agent_id".to_string()),
                values: Some(vec!["agent-1".to_string(), "agent-2".to_string()]),
                max_requests: None,
                window_seconds: None,
                max_amount: None,
                currency: None,
                resource: None,
            }],
        };

        let code = generate_express_middleware(&policy_file, "test.yaml");
        assert!(code.contains("x402Middleware"));
        assert!(code.contains("allowedAgents"));
        assert!(code.contains("agent-1"));
        assert!(code.contains("agent-2"));
        assert!(code.contains("status(403)"));
    }

    #[test]
    fn test_generate_middleware_with_rate_limit() {
        let policy_file = PolicyFile {
            policies: vec![PolicyRule {
                policy_type: PolicyType::RateLimit,
                field: None,
                values: None,
                max_requests: Some(100),
                window_seconds: Some(3600),
                max_amount: None,
                currency: None,
                resource: None,
            }],
        };

        let code = generate_express_middleware(&policy_file, "test.yaml");
        assert!(code.contains("rateLimitExceeded"));
        assert!(code.contains("100"));
        assert!(code.contains("3600"));
        assert!(code.contains("status(429)"));
    }

    #[test]
    fn test_generate_complete_middleware() {
        let policy_file = PolicyFile {
            policies: vec![
                PolicyRule {
                    policy_type: PolicyType::Allowlist,
                    field: Some("agent_id".to_string()),
                    values: Some(vec!["agent-123".to_string()]),
                    max_requests: None,
                    window_seconds: None,
                    max_amount: None,
                    currency: None,
                    resource: None,
                },
                PolicyRule {
                    policy_type: PolicyType::RateLimit,
                    field: None,
                    values: None,
                    max_requests: Some(50),
                    window_seconds: Some(60),
                    max_amount: None,
                    currency: None,
                    resource: None,
                },
            ],
        };

        let code = generate_express_middleware(&policy_file, "policy.yaml");

        // Check header
        assert!(code.contains("Generated by: x402-dev"));

        // Check helpers
        assert!(code.contains("function rateLimitExceeded"));
        assert!(code.contains("function generateInvoice"));
        assert!(code.contains("function logPaymentAttempt"));

        // Check middleware
        assert!(code.contains("const x402Middleware"));
        assert!(code.contains("allowedAgents"));
        assert!(code.contains("rateLimitExceeded"));
        assert!(code.contains("status(402)"));
        assert!(code.contains("WWW-Authenticate"));

        // Check export
        assert!(code.contains("module.exports"));
    }
}
