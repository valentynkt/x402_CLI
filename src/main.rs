use actix_web::{web, App, HttpResponse, HttpServer, Result};
use serde::{Deserialize, Serialize};
use std::sync::Mutex;

/// Represents a payment invoice generated by x402-dev
#[derive(Serialize, Deserialize)]
struct X402Invoice {
    amount: u64,        // Amount in lamports (1 SOL = 1,000,000,000 lamports)
    currency: String,   // "SOL" for Solana payments
    address: String,    // Payment destination address
    expires_at: String, // ISO 8601 timestamp
}

/// Response sent when payment is required (402 status)
#[derive(Serialize)]
struct PaymentRequiredResponse {
    error: String,
    amount_lamports: u64,
    message: String,
}

/// Successful data response after payment verification
#[derive(Serialize)]
struct DataResponse {
    data: String,
    timestamp: String,
}

/// Simple in-memory store to track paid requests
/// In production, use Redis or a proper database
struct AppState {
    paid_requests: Mutex<Vec<String>>, // Store payment transaction IDs
}

/// Main endpoint that requires payment to access
/// Returns 402 Payment Required with x402 invoice on first request
async fn get_data(data: web::Data<AppState>, req: actix_web::HttpRequest) -> Result<HttpResponse> {
    // Check if payment header exists (would come from x402-dev proxy)
    if let Some(payment_proof) = req.headers().get("X-402-Payment-Proof") {
        let tx_id = payment_proof.to_str().unwrap_or("");

        // Verify payment hasn't been used before (prevent replay attacks)
        let mut paid = data.paid_requests.lock().unwrap();
        if paid.contains(&tx_id.to_string()) {
            return Ok(
                HttpResponse::PaymentRequired().json(PaymentRequiredResponse {
                    error: "Payment already used".to_string(),
                    amount_lamports: 1000,
                    message: "This payment proof has already been redeemed".to_string(),
                }),
            );
        }

        // Mark payment as used
        paid.push(tx_id.to_string());

        // Payment verified - return protected data
        return Ok(HttpResponse::Ok().json(DataResponse {
            data: "Protected content accessed successfully! ğŸ‰".to_string(),
            timestamp: chrono::Utc::now().to_rfc3339(),
        }));
    }

    // No payment - generate x402 invoice
    // In production, x402-dev daemon would generate this dynamically
    let invoice = X402Invoice {
        amount: 1000, // 0.000001 SOL (1000 lamports) for testing
        currency: "SOL".to_string(),
        address: "x402DevDaemonGeneratesThis".to_string(), // x402-dev replaces this
        expires_at: chrono::Utc::now()
            .checked_add_signed(chrono::Duration::minutes(15))
            .unwrap()
            .to_rfc3339(),
    };

    // Return 402 Payment Required with invoice details
    Ok(HttpResponse::PaymentRequired()
        .insert_header(("X-402-Invoice", serde_json::to_string(&invoice).unwrap()))
        .insert_header(("Access-Control-Allow-Origin", "*")) // Allow CORS for testing
        .json(PaymentRequiredResponse {
            error: "Payment required".to_string(),
            amount_lamports: 1000,
            message: "Pay 0.000001 SOL to access this endpoint".to_string(),
        }))
}

/// Health check endpoint (free, no payment required)
async fn health_check() -> Result<HttpResponse> {
    Ok(HttpResponse::Ok().json(serde_json::json!({
        "status": "healthy",
        "service": "MCP Server with x402 Payments",
        "version": "1.0.0"
    })))
}

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    // Initialize shared state
    let app_state = web::Data::new(AppState {
        paid_requests: Mutex::new(Vec::new()),
    });

    println!("ğŸš€ Starting MCP Server with x402 Payments...");
    println!("ğŸ“¡ Server running at: http://localhost:8402");
    println!("ğŸ’° Payment endpoint: http://localhost:8402/data");
    println!("ğŸ¥ Health check: http://localhost:8402/health");
    println!("\nâ„¹ï¸  Make sure x402-dev daemon is running:");
    println!("   x402-dev start\n");

    // Start HTTP server
    HttpServer::new(move || {
        App::new()
            .app_data(app_state.clone())
            .route("/data", web::get().to(get_data))
            .route("/health", web::get().to(health_check))
    })
    .bind(("127.0.0.1", 8402))?
    .run()
    .await
}
